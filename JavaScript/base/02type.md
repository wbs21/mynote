### 数据类型和变量

------

#### 数据类型

计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在JavaScript中定义了以下几种数据类型：

#### Number

JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型：

```
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
```

计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：`0xff00`，`0xa5b4c3d2`，等等，它们和十进制表示的数值完全一样。

Number可以直接做四则运算，规则和数学一致：

```
1 + 2; // 3
(1 + 2) * 5 / 2; // 7.5
2 / 0; // Infinity
0 / 0; // NaN
10 % 3; // 1
10.5 % 3; // 1.5
```

注意`%`是求余运算。

#### 字符串

字符串是以单引号'或双引号"括起来的任意文本，比如`'abc'`，`"xyz"`等等。请注意，`''`或`""`本身只是一种表示方式，不是字符串的一部分，因此，字符串`'abc'`只有`a`，`b`，`c`这3个字符。

#### 布尔值

布尔值和布尔代数的表示完全一致，一个布尔值只有`true`、`false`两种值，要么是`true`，要么是`false`，可以直接用`true`、`false`表示布尔值，也可以通过布尔运算计算出来：

```
true; // 这是一个true值
false; // 这是一个false值
2 > 1; // 这是一个true值
2 >= 3; // 这是一个false值
```

`&&`运算是与运算，只有所有都为`true`，`&&`运算结果才是`true`：

```
true && true; // 这个&&语句计算结果为true
true && false; // 这个&&语句计算结果为false
false && true && false; // 这个&&语句计算结果为false
```

`||`运算是或运算，只要其中有一个为`true`，`||`运算结果就是`true`：

```
false || false; // 这个||语句计算结果为false
true || false; // 这个||语句计算结果为true
false || true || false; // 这个||语句计算结果为true
```

`!`运算是非运算，它是一个单目运算符，把`true`变成`false`，`false`变成`true`：

```
! true; // 结果为false
! false; // 结果为true
! (2 > 5); // 结果为true
```

布尔值经常用在条件判断中，比如：

```
var age = 15;
if (age >= 18) {
    alert('adult');
} else {
    alert('teenager');
}
```

### 比较运算符

当我们对Number做比较时，可以通过比较运算符得到一个布尔值：

```
2 > 5; // false
5 >= 2; // true
7 == 7; // true
```

实际上，JavaScript允许对任意数据类型做比较：

```
false == 0; // true
false === 0; // false
```

要特别注意相等运算符`==`。JavaScript在设计时，有两种比较运算符：

第一种是`==`比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；

第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回`false`，如果一致，再比较。

由于JavaScript这个设计缺陷，*不要*使用`==`比较，始终坚持使用`===`比较。

另一个例外是`NaN`这个特殊的Number与所有其他值都不相等，包括它自己：

```
NaN === NaN; // false
```

唯一能判断`NaN`的方法是通过`isNaN()`函数：

```
isNaN(NaN); // true
```

最后要注意浮点数的相等比较：

```
1 / 3 === (1 - 2 / 3); // false
```

这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：

```
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```

#### null和undefined

`null`表示一个“空”的值，它和`0`以及空字符串`''`不同，`0`是一个数值，`''`表示长度为0的字符串，而`null`表示“空”。

在其他语言中，也有类似JavaScript的`null`的表示，例如Java也用`null`，Swift用`nil`，Python用`None`表示。但是，在JavaScript中，还有一个和`null`类似的`undefined`，它表示“未定义”。

JavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在判断函数参数是否传递的情况下有用。

#### 数组

数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：

```
[1, 2, 3.14, 'Hello', null, true];
```

上述数组包含6个元素。数组用`[]`表示，元素之间用`,`分隔。

另一种创建数组的方法是通过`Array()`函数实现：

```
new Array(1, 2, 3); // 创建了数组[1, 2, 3]
```

然而，出于代码的可读性考虑，强烈建议直接使用`[]`。

数组的元素可以通过索引来访问。请注意，索引的起始值为`0`：

```
var arr = [1, 2, 3.14, 'Hello', null, true];
arr[0]; // 返回索引为0的元素，即1
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
```

#### 对象

JavaScript的对象是一组由键-值组成的无序集合，例如：

```
var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null
};
```

JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述`person`对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，`person`的`name`属性为`'Bob'`，`zipcode`属性为`null`。

要获取一个对象的属性，我们用`对象变量.属性名`的方式：

```
person.name; // 'Bob'
person.zipcode; // null
```

### 变量

变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。

变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、`$`和`_`的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如`if`、`while`等。申明一个变量用`var`语句，比如：

```
var a; // 申明了变量a，此时a的值为undefined
var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1
var s_007 = '007'; // s_007是一个字符串
var Answer = true; // Answer是一个布尔值true
var t = null; // t的值是null
```

变量名也可以用中文，但是，请不要给自己找麻烦。

在JavaScript中，使用等号`=`对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用`var`申明一次，例如：

```
var a = 123; // a的值是整数123
a = 'ABC'; // a变为字符串
```

这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：

```
int a = 123; // a是整数类型变量，类型用int申明
a = "ABC"; // 错误：不能把字符串赋给整型变量
```

和静态语言相比，动态语言更灵活，就是这个原因。

请不要把赋值语句的等号等同于数学的等号。比如下面的代码：

```
var x = 10;
x = x + 2;
```

如果从数学上理解`x = x + 2`那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式`x + 2`，得到结果`12`，再赋给变量`x`。由于`x`之前的值是`10`，重新赋值后，`x`的值变成`12`。

要显示变量的内容，可以用`console.log(x)`，打开Chrome的控制台就可以看到结果。

### JavaScript中的6种数据类型。

#### 6种数据类型简介

可分为两大类：简单数据类型和复杂数据类型。

说明一下：上面这句话现在来说应该是不对的，因为ES6中新增了数据类型。*不过我们暂时不涉及ES6。*

简单数据类型即基本数据类型，共有5种：Undefined、Null、Boolean、Number、String，其值分别对应undefined、null、布尔值true和false、数值、字符串值。

复杂数据类型只有一种，就是Object——对象。JS中的对象就是一组无序键值对外面套一个大括号{}所构成。Object非常常用、非常强大、非常有意思，而且对于JS这门语言结构来说，Object意义不一般。这些，之后的文章再来讨论吧。

> ECMAScript不支持任何创建自定义类型的机制，而所有值最终都将是上述6种数据类型之一。

上面这句话引用自《JavaScript高级程序设计（第3版）》（之后简称J3），其实不用多解释，这句话说的很明白了。这就是说，你“定义”的所有变量，它的类型都是唯一确定的，必定是上述6种之一。

这里的“定义”两个字，我加了引号，是想表示这个词广义上的意思。在一般的编程语言中，当你想“定义”一个变量时，不外乎3种情况：声明，定义，初始化。声明就如字面意思一样，仅仅是宣称一个命名；定义就是给这个命名分配内存空间；初始化则是给这个内存空间赋值。显然，他们3个是循序渐进的。在JS中，我们所说的初始化其实做的事是分配内存并赋值，也就是定义并初始化。所以在JS中，我们一般只说声明和初始化。看如下代码：

```
var value1; //声明变量

value1 = 'Hello'; //（定义并）初始化

var value2 = 'Hello'; //声明并初始化
```

再摘录博客园的一句话，对于声明、定义与初始化大家应该就能完全理解了：

> 因为javascript为动态语言，其变量并没有固定的类型，其存储空间大小会随初始化与赋值而变化，所以其变量的“定义”就不像传统的静态语言一样了，其定义显得无关紧要。

------

接下来，让我们来具体看一看JavaScript的6种数据类型。

不过首先，必须先了解一个操作符—typeof。顾名思义，这个操作符的作用就是返回某个变量的数据类型。对某个值使用typeof操作符始终会返回以下6个字符串之一：'undefined'、'boolean'、'number'、'string'、'object'、'function'。你肯定发现了一个问题，就是这6个字符串为什么不和6种数据类型完全对应？没有'null'吗？'function'又是哪儿来的？请看下面的测试代码：

```
console.log(typeof null) //'object'

var f = function(){};

console.log(typeof f); //'function'
```

注意到，对Null类型的唯一值null使用typeof操作符返回的不是什么'null'，而是'object'，这是为什么呢？这是因为null这个值比较特殊，它是基本数据类型Null的唯一值，但同时，它又被认为是一个空的对象(Object)引用。

> 有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用typeof null会返回"object"，因为特殊值null 被认为是一个空的对象引用。——《J3》

对于typeof可以返回'function'，这么理解吧：

> 从技术角度讲，函数在ECMAScript 中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过typeof 操作符来区分函数和其他对象是有必要的。——《J3》

在JS中，Function和Object的关系很微妙也很复杂，需要对原型构造、原型链等一些知识有所理解之后才能进一步理解这两者的关系。不过这并不影响我们现在的理解，站在数据类型的角度，我们可以明确地认为Function就是一类特殊的Object。至于对一个Function使用typeof操作符的返回结果是'function'而不是'object'，原因就像书上说的，只是因为我们有必要知道它是一个函数而不是一般的对象。

------

介绍完typeof操作符这个实用的工具，下面就真的具体来看看JS的6种数据类型吧。

#### Undefined 类型

- 只有一个唯一值，即undefined。
- 所有只进行了声明而未初始化的变量，其值都是undefined。比如：

```
var a;

console.log(a); //undefined（注意，这可不是字符串）
```



需要明白的是，undefined是一个明确的、合法的值，而不是一个错误。真正会导致错误的是如下的代码：

```
console.log(b); //Uncaught ReferenceError: b is not defined
```



这行代码会报一个空引用异常的错误，因为变量b没有声明。这很好理解。

- 还有一点需要了解，对于上边两段示例代码中的变量 a 和 b，执行typeof操作都会返回'undefined'：

```
var a;

console.log(typeof a); //'undefined'

console.log(typeof b); //'undefined'
```

看起来，你可能会觉得对 b 执行typeof应该报错才对，但因为typeof必然会返回6个字符串之一，所以并不会报错。而且，无论是 a 还是 b，都无法执行真正的操作，那么就让 b 和 a 一样返回'undefined'好了。看一下书上的解释：

> 结果表明，对未初始化和未声明的变量执行typeof 操作符都返回了undefined 值；这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。——《J3》

由此可知，当你使用typeof操作符检测变量的数据类型时，如果返回的是'undefined'，那么这个变量可能是未初始化，也可能是未声明。因此，从规范性上来说，为了避免这种模糊，我们在定义变量时最好直接进行初始化。这样的话，如果还返回'undefined'，那么我们立即就能知道是因为这个变量压根就没声明了。

#### Null 类型

- 只有一个唯一值，即null。
- null表示一个空对象(Object)引用，因此typeof null会返回'object'。
- 实际上，undefined派生自null，因此undefined == null返回true，但是undefined === null会返回false，因为这两个值的数据类型不一样。这里补充一下：==是相等操作符，===是全等操作符，前者会对操作数自动进行转型，而后者不会，后者只有在两个操作数未经转换就相等的情况下才返回true。
- 还有一点，如果某个变量用来在以后保存对象，那么最好将其初始化为null，以方便区分和判断。

#### Boolean 类型

- 布尔类型，有2个值：true和false。
- 其他所有数据类型都有与true和false对应的值，通过转型函数Boolean()可以得到某个值所对应的布尔值。如：

```
var s = 'Hello';
console.log(Boolean(s)); //true
```

转换规则如下表：

数据类型    转换后为true      转换后为false

String        任何非空字符串  空串''

Number    任何非零数值     0和NaN

Object      任何对象            null

Undefined  N/A不适用      undefined



Boolean()转型函数的转换规则

在流程控制语句中，比如在if语句的小括号内，会自动对操作数调用转型函数Boolean()再求最终的布尔值。如下：

```
var s = 'Hello';
if(s){
//do something //后台自动对s调用转型函数`Boolean()`，因为s不是空串，会返回true
}
```

#### Number 类型

数值类型。了解几个知识点即可。

- 保存浮点数所需的内存空间是整数值的2倍；
- 永远不要测试特定的浮点数值，如：

- ```
  var a = 0.1;
  var b = 0.2;
  console.log(a + b); //0.30000000000000004 有误差，并不会是0.3
  ```

  NaN是一个特殊的Number值，它的存在是为了避免程序直接报错，比如0/0的结果就是NaN；NaN的任何操作都会返回NaN；NaN与任何值都不相等，包括它本身：NaN === NaN会返回false；

- 另外，还有parseInt()和parseFloat()等常用转型函数的用法自行Google即可。

#### String 类型

字符串类型。在这里了解几个点即可，之后在引用类型等处会做详细介绍。

- 单引号''和双引号""都可以使用且没有任何差别。

- > ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。——《J3》

- 将某个值转换为字符串，可以使用以下3种方法：toString()方法、转型函数String()、加空串+ ''。

#### Object 类型

对象类型。Object是所有对象的基础，其所具有的属性和方法其他对象也必然拥有。这里只列几个Object的属性和方法：

- constructor：保存着用于创建当前对象的构造函数；
- hasOwnProperty('属性名')：用于检查给定的属性在当前对象实例中是否存在（不查找原型链）；
- isPrototypeOf(某一Object类型)：用于检查对象实例是否是传入对象的原型；
- propertyIsEnumerable('属性名')：用于检查传入的属性是否可以枚举；
- toString()：返回该对象的字符串表示；
- toLocalString()：同上，与所在地区有关
- valueOf()：返回对象最有意义的那个值，返回的可能是字符串、数值或者布尔值。